# Lecture 4
{:.no_toc}

* TOC
{:toc}

## Pixels

* Last week, we took a look at memory and how we could use arrays to store data.
* We might zoom in further and further in an image, but very soon we’ll see individual pixels, like the ones in this puppet’s eye:

  <img src="eyes.png" width="400">

  * Since this image is stored with a finite number of bytes, each perhaps representing a red, green, or blue value for each pixel, there is in turn a finite number of pixels we can see.
* A simpler image of a smiley face might be represented with a single bit per pixel:

  <img src="smiley.png" width="600">

* We can visit [cs50.ly/art](https://cs50.ly/art) with a Google Account to make a copy of a spreadsheet, which we can then fill with colors to create our own [pixel art](https://en.wikipedia.org/wiki/Pixel_art).
* [Adobe Photoshop](https://en.wikipedia.org/wiki/Adobe_Photoshop), a popular image editing software, includes a color picker that looks like this:

  <img src="color_picker.png" width="400">

  * Here, the color black is selected, and we see that the values for R, G, and B, or red, green, and blue respectively, are all 0. Furthermore, we see another value, #000000 that seems to represent all three values for the color black.
* We take a look at a few more colors:
  * white, with R: 255, G: 255, and B: 255, and #FFFFFF
  * red, with R: 255, G: 0, and B: 0, and #FF0000
  * green, with R: 0, G: 255, and B: 0, and #00FF00
  * blue, with R: 0, G: 0, and B: 255, and #0000FF

## Hexadecimal

* We might notice a pattern for the new notation, where it appears that each value for red, green, and blue are represented with two characters. It turns out that there’s another base system, **hexadecimal**, or base-16, where there are 16 digits:
  ```
  0 1 2 3 4 5 6 7 8 9 A B C D E F
  ```
	* The digits start with 0 through 9, and continue with A through F as equivalents to the decimal values of 10 through 15.
* Let’s consider a two-digit hexadecimal number:
	```
	16^1 16^0
	   0    0
	```
	* Here, the `0` in the ones place (since $16^0 = 1$) has a decimal value of 0. We’ll count up, and after `09` we’ll use `0A` to represent 10 in decimal.
	* We can keep counting until `0F`, which is equivalent to 15 in decimal.
* After `0F`, we need to carry the one, as we would go from 9 to 10 in decimal:
	```
	16^1 16^0
	   1    0
	```
	* Here, the `1` has a value of $16^1 \times 1 = 16$, so `10` in hexadecimal is 16 in decimal.
* With two digits, we can have a maximum value of FF, or $16^1 \times 15 + 16^0 \times 15 = 16 \times 15 + 1 \times 15 = 240 + 15 = 255$
.
	* The values in a computer’s memory are still stored as binary, but this way of representation helps us humans represent larger numeric values with fewer digits needed.
	* With 8 bits in binary, the highest value we can count to is also 255, with `11111111`. So two digits in hexadecimal can conveniently represent the value of a byte in binary. (Each digit in hexadecimal, with 16 values, maps to four bits in binary.)

## Addresses, pointers

* For our computer’s memory, too, we’ll see hexadecimal used to describe each address or location:

	<img src="addresses.png" width="600">

	* By writing `0x` in front of a hexadecimal value, we can distinguish them from decimal values.
* We might create a value `n`, and print it out:
	```c
	#include <stdio.h>
	
	int main(void)
	{
	    int n = 50;
	    printf("%i\n", n);
	}
	```
* In our computer’s memory, there are now 4 bytes somewhere that have the binary value of 50, with some value for its address, like `0x123`:

	<img src="50.png" width="600">

* A **pointer** is a variable that stores an address in memory, where some other variable might be stored.
* The **`&`** operator can be used to get the address of some variable, as with `&n`. And the `*` operator declares a variable as a pointer, as with `int *p`, indicating that we have a variable called `p` that *points to* an `int`. So, to store the address of a variable `n` into a pointer `p`, we would write:
	```c
	int *p = &n;
	```
* In C, we can actually see the address with the `&` operator, which means “get the address of this variable”:
	```c
	#include <stdio.h>
	
	int main(void)
	{
	    int n = 50;
	    int *p = &n;
	    printf("%p\n", p);
	}
	```
	```
	$ make address
	$ ./address
	0x7ffcb4578e5c
	```
	* `%p` is the format code to print an address with `printf`. And we only need to use the name of the variable, `p`, after we’ve declared it.
	* In our instance of VS Code, we see an address with a large value like `0x7ffcb4578e5c`. The value of the address in itself is not significant, since it’s just some location in memory that the variable is stored in; instead, the important idea is that we can use this address later.
	* We can run this program a few times, and see that the address of `n` in memory changes, since different addresses in memory will be available at different times.
* With C, we can also go to specific addresses in memory, which might cause **segmentation faults**, where we’ve tried to read or write to memory we don’t have permission to.
* The `*` operator is also the **dereference operator**, which goes to an address to get the value stored there. For example, we can say:
	```c
	#include <stdio.h>
	
	int main(void)
	{
	    int n = 50;
	    int *p = &n;
	    printf("%p\n", p);
	    printf("%i\n", *p);
	}
	```
	```
	$ ./address
	0x7ffda0a4767c
	50
	```
	* Now, we see the value of the pointer itself (an address), and then the value at the address with `*p`, which is `50`.
	* Since we declared `p` to be an `int *`, the compiler knows that `*p` is an `int`, so the right number of bytes are read.
* In memory, we might have one variable, `p`, with the value of some address, like `0x123`, stored, and another variable, an integer with the value `50`, at that addresss:

	<img src="p.png" width="600">

	* Notice that `p` takes up 8 bytes, since in modern computer systems, 64 bits are used in order to address the billions of bytes of memory available. With 32 bits, we can only count up to about 4 billion bytes, or about 4GB of memory.
* We can abstract away the actual value of the addresses, since they’ll be different as we declare variables in our programs. We can simply think of `p` as pointing at some value in memory:

	<img src="" width="600">

* In the real world, we might have a mailbox labeled “p”, among many mailboxes with addresses. Inside our mailbox, we can put a value like `0x123`, which is the address of some other mailbox that’s labeled “n”.